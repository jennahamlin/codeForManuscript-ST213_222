---
title: "Supplemental Material for Expanded Geographic Distribution for Two *Legionella pneumophila* Sequence Types of Clinical Concern"
subtitle: "Geographic increase of *L. pneumophila* ST213/222"
output: 
    word_document: default
    bookdown::word_document2:
    keep_tex: true
    citation_package: biblatex
    latex_engine: lualatex
bibliography: myLibraryShort.bib
csl: american-society-for-microbiology.csl
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(stringr)
library(magrittr)
library(here)
library(english)
library(reshape2)

# in yaml at one point i needed this biblatexoptions: [backend=biber, maxbibnames=999]


## Requires tinytex R package and the TinyTex Latex Distribution
## tinytex::install_tinytex()
## install.packages("tinytex")
```

```{r st222 Meta, message=FALSE, warning=FALSE, echo=FALSE}

########################
#        META          #
########################

## Read in the metadata for this manuscript
isoLoc <- read.csv(here::here('02_Manuscript/inputFiles',
                              'supplementalTable2Metadata-ST222.csv'),
                   header = T, stringsAsFactors = F)

## Filter isolates which should not be used
isoLoc <- isoLoc %>%  
  dplyr::filter(isolateAccession != "C180" & isolateAccession != "U10")

## What is minimum years for ST213/ST222 clonal complex
minYear <- isoLoc %>%
  dplyr::filter(elGatoSTCalls == '213' | elGatoSTCalls == '222' ) %>%
  dplyr::filter(Year != "Unknown") %>%
  summarise(Year = min(Year)) 

## What is maximum years for ST22/213 clonal complex
maxYear <- isoLoc %>%
  dplyr::filter(elGatoSTCalls == '213' | elGatoSTCalls == '222') %>%
  dplyr::filter(Year != "Unknown") %>%
  summarise(Year = max(Year)) 

## Determine US states with the highest percent of clinical isolates,
## independent of ST
isoOrigin <-  isoLoc %>% 
  dplyr::filter(Source != 'Environmental' & Source != 'Unknown') %>%
  dplyr::select(Year, State) %>%       #select these two columns 
  dplyr::group_by(State) %>%          
  dplyr::summarize(caseCount = n()) %>%
  dplyr::arrange(desc(caseCount))

## Convert state abbreviations to state names
isoOrigin$State <- state.name[match(isoOrigin$State, state.abb)]

## Get total isolates parsed by states. Used to calculate
## the percent
totalOrg <- sum(isoOrigin$caseCount)

## Total isolates, must exclude C180 (canada), U10, and U12
totST <- isoLoc %>%
  dplyr::tally()

## Get counts parsed by sample set(cdc vs state)
sampleSetST <- isoLoc %>%
  dplyr::group_by(samplesSet) %>%
  dplyr::tally()

## Count by STs used in manuscript 
stCount <- isoLoc %>%
  na.omit %>% 
  group_by(elGatoSTCalls) %>%
  dplyr::summarize(caseCount = n())

## Source counts
sourceCount <- isoLoc %>% 
  group_by(Source) %>% 
  dplyr::tally()

## Counts for isolates with an unknown collection year
noYear <-  isoLoc %>%
  dplyr::filter(Year == 'Unknown') %>%
  dplyr::tally()

## Get counts parsed by state submitted sequences and the
## associated states
stateSampleSet <- isoLoc %>%
  dplyr::group_by(samplesSet, State) %>%
  dplyr::filter(samplesSet != 'cdc') %>%
  dplyr::tally()

stateSampleSet$State <- state.name[match(stateSampleSet$State, state.abb)]

## Get counts for region bins
regionCount <- isoLoc %>%
  dplyr::filter(panGenomeRegion == 'Include') %>%
  dplyr::group_by(Region) %>%
  dplyr::tally()

## Get counts for year bins
yearBin <- isoLoc %>%
  dplyr::filter(whyExcludeYear == 'None') %>%
  dplyr::group_by(panGenomeYear) %>%
  dplyr::tally()

## Get counts parsed by years
yearCount <- isoLoc %>%
  group_by(Year) %>%
  dplyr::tally()

## Get counts of cases parsed by type (sporadic vs outbreak)
totSporadic <- isoLoc %>%
  dplyr::filter(Source != 'Environmental' & Source != 'Unknown') %>%
  group_by(elGatoSTCalls, Type) %>%
  dplyr::tally()

## Get counts of total sporadic cases for ST213/222
jst213222Spor <- totSporadic %>%
  dplyr::filter(Type == 'Sporadic') %>%
  dplyr::filter(elGatoSTCalls == "213" | elGatoSTCalls == "222")

## Get total counts parsed by ST fr sporadic cases for only 2019
yearSporadic <- isoLoc %>%
  group_by(elGatoSTCalls, Type, Year) %>%
  dplyr::filter(Year == 2019) %>%
  dplyr::tally()

## Get number of isolates classified as outbreak
outbreakCount <- isoLoc %>% 
  group_by(Type) %>% 
  dplyr::tally()

## Get counts of clinical, environmental, and unknown parsed by ST
typeCount <- isoLoc %>% 
  group_by(Source, elGatoSTCalls) %>% 
  dplyr::tally()

```

```{r, st222 Rate, echo = FALSE, warning =  FALSE, message = FALSE}
########################
#         RATE        #
########################
## Code block to determine st222/213 rate (frequency) of cases
## Data was read in the st222 Meta code block above
isoLoc$Year<- as.numeric(gsub(",", "", isoLoc$Year))
isoLoc$ST <- as.numeric(gsub(",", "", isoLoc$elGatoSTCalls))

## Summarize case counts by years
isoCount <- isoLoc %>% 
  dplyr::filter(Source != 'Environmental' & Source != 'Unknown') %>%
  dplyr::select(Year, Type, State) %>%        #select these two columns 
  dplyr::rename(year = Year) %>%
  dplyr::group_by(year) %>%          
  dplyr::summarize(caseCount = n()) #count summary & rename column header

## Remove years which are on either side of the years
## with zero cases (1992-1996)
isoCount <- isoCount %>% 
  dplyr::slice(-c(1:2))       

## Remove years which are on either side of the years
## with zero cases (1998-2000)
isoCount <- isoCount %>%
  dplyr::slice(-c(2:3))       

## Dealing with the years with zero cases. Assign a calculated rate
## for years which were removed due to zero cases. So 1992-1996
## will result in a rate of 0.04 (i.e., n cases = 2, n years = 5, 2/5)
## for each year. 1998-2000 will have a rate of 0.667 (2/3)
isoCount <- rbind(isoCount, c(1992, 2/5))
isoCount <- rbind(isoCount, c(1993, 2/5))
isoCount <- rbind(isoCount, c(1994, 2/5))
isoCount <- rbind(isoCount, c(1995, 2/5))
isoCount <- rbind(isoCount, c(1996, 2/5))

isoCount <- rbind(isoCount, c(1998, 2/3))
isoCount <- rbind(isoCount, c(1999, 2/3))
isoCount <- rbind(isoCount, c(2000, 2/3))

isoCount <- isoCount[order(isoCount$year),]

## Take the log of casecount column
isoCount$caseCount <- log(isoCount$caseCount)

## Generate a linear model to estimate slope and
## intercept for log values
lModel <- lm(caseCount ~ year, data = isoCount[1:29,])

st222Mod <- summary(lModel)
```

```{r, st222 ANI, echo = FALSE, warning =  FALSE, message = FALSE}
########################
#    INTRA - ANI       #
########################

## Function to data wrangle matrix and calculate mean by ST
meanANI <- function(df){
  myDF <-  read.csv(here::here('02_Manuscript/inputFiles',
                               df),
                    header = T, stringsAsFactors = F, sep="\t")
  ## Data wrangling - remove upper matrix
  myDF[upper.tri(myDF)] <-NA
  
  names(myDF) <- NULL
  myDF <- myDF[,-1]
  
  myDFOut <- as.numeric(unlist(myDF))
  myDFMean <- mean(myDFOut, na.rm =T) 
  myDFMean
}

## 99.92043
ani213Mean <- meanANI('ani-mummer213.txt')

## 99.91591
ani222Mean <- meanANI('ani-mummer222.txt')

########################
#    INTER - ANI       #
########################

## Read in the metadata for this manuscript. This is the pairwise ANI file
allANI <- read.csv(here::here('02_Manuscript/inputFiles',
                              'supplementalTable4ANI-All.csv'),
                   header = T,stringsAsFactors = F)

## Data wrangling - remove upper matrix include 100 diagnol
allANI[upper.tri(allANI)] <-NA

## Remove clonal isolates and non 213/222 isolates,
## this removal is completed in two steps by row and column 
allANIReduced <- subset(allANI,
                        select=-c(C166.O_OH.2013.OC.ST1742,
                                  C184.S_IN.2006.CS.ST289,
                                  C185.S_NY.2006.CS.ST289, 
                                  C198.S_CT.2005.CS.ST276, 
                                  C214.S_NY.2015.CS.ST289,  
                                  C241.S_OH.2019.CS.STUNK,
                                  C291.O_OH.2013.OC.ST222,
                                  C365.S_MN.2014.CS.ST227, 
                                  C366.S_MN.2016.CS.ST227, 
                                  C367.S_IN.2016.CS.ST289, 
                                  E155.O_OH.2013.OE.ST222, 
                                  E156.O_OH.2013.OE.ST222,
                                  E157.O_OH.2013.OE.ST222,	
                                  E159.O_OH.2013.OE.ST222,
                                  E160.O_OH.2013.OE.ST222, 
                                  E161.O_MI.2010.OE.ST222,
                                  E162.O_MI.2010.OE.ST222,
                                  E163.O_MI.2010.OE.ST222, 
                                  E164.O_MI.2010.OE.ST222,
                                  E166.O_VT.2002.OE.ST222,
                                  E167.O_MD.2009.OE.ST222,
                                  E168.O_MD.2009.OE.ST222,
                                  E169.O_MD.2009.OE.ST222, 
                                  E170.O_MD.2009.OE.ST222,
                                  E171.O_MD.2009.OE.ST222,
                                  E174.O_OH.2013.OE.ST222,
                                  U12.U_NY.Unknown.UNK.ST2517))	

## Step two in removing certain isolates (clonal or non-ST213/222)
allANI <- allANIReduced[!(allANIReduced$X == "C166-O_OH-2013-OC-ST1742" | 
                             allANIReduced$X == "C184-S_IN-2006-CS-ST289" |
                             allANIReduced$X == "C185-S_NY-2006-CS-ST289" |
                             allANIReduced$X == "C198-S_CT-2005-CS-ST276" |
                             allANIReduced$X == "C214-S_NY-2015-CS-ST289" |
                             allANIReduced$X == "C241-S_OH-2019-CS-STUNK" | 
                             allANIReduced$X == "C291-O_OH-2013-OC-ST222" |
                             allANIReduced$X == "C365-S_MN-2014-CS-ST227" |
                             allANIReduced$X == "C366-S_MN-2016-CS-ST227" |
                             allANIReduced$X == "C367-S_IN-2016-CS-ST289" |
                             allANIReduced$X == "E155-O_OH-2013-OE-ST222" |
                             allANIReduced$X == "E156-O_OH-2013-OE-ST222" |
                             allANIReduced$X == "E157-O_OH-2013-OE-ST222" |
                             allANIReduced$X == "E159-O_OH-2013-OE-ST222" |
                             allANIReduced$X == "E160-O_OH-2013-OE-ST222" |
                             allANIReduced$X == "E161-O_MI-2010-OE-ST222" |
                             allANIReduced$X == "E162-O_MI-2010-OE-ST222" |
                             allANIReduced$X == "E163-O_MI-2010-OE-ST222" |
                             allANIReduced$X == "E164-O_MI-2010-OE-ST222" |
                             allANIReduced$X == "E166-O_VT-2002-OE-ST222" |
                             allANIReduced$X == "E167-O_MD-2009-OE-ST222" |
                             allANIReduced$X == "E168-O_MD-2009-OE-ST222" |
                             allANIReduced$X == "E169-O_MD-2009-OE-ST222" |
                             allANIReduced$X == "E170-O_MD-2009-OE-ST222" |
                             allANIReduced$X == "E171-O_MD-2009-OE-ST222" |
                             allANIReduced$X == "E174-O_OH-2013-OE-ST222" |
                             allANIReduced$X == "U12-U_NY-Unknown-UNK-ST2517" ),]

## Name replacement as a dataframe part 1
old_member_type <- c("C232-S_OH-2018-CS-STUNK", "C234-S_WI-2018-CS-STUNK",
                     "C236-S_IN-2019-CS-STUNK", "C239-S_OH-2019-CS-STUNK",
                     "C241-S_OH-2019-CS-STUNK", "C245-S_OH-2019-CS-STUNK",
                     "C346-S_IN-2017-CS-STUNK", "C347-S_MN-2018-CS-STUNK",  
                     "C348-S_MN-2019-CS-STUNK", "C349-S_MI-2018-CS-STUNK",
                     "C350-S_MI-2019-CS-STUNK", "C351-S_MI-2019-CS-STUNK",
                     "C352-S_MI-2019-CS-STUNK", "C353-S_MI-2019-CS-STUNK",
                     "C354-S_NY-2018-CS-STUNK", "C355-S_NY-2018-CS-STUNK", 
                     "C356-S_NY-2018-CS-STUNK", "C357-S_NY-2018-CS-STUNK",   
                     "C358-S_NY-2018-CS-STUNK", "C359-S_MN-2019-CS-STUNK", 
                     "C360-S_MN-2019-CS-STUNK", "C361-S_MN-2019-CS-STUNK",
                     "C362-S_MN-2019-CS-STUNK", "C363-S_MN-2019-CS-STUNK", 
                     "C364-S_MN-2019-CS-STUNK", "U1-U_MA-UNK-UNK-STUNK",     
                     "U11-U_NY-Unknown-UNK-STUNK", "U3-U_MA-UNK-UNK-STUNK", 
                     "U4-U_MA-UNK-UNK-STUNK", "U5-U_MA-UNK-UNK-STUNK",     
                     "U6-U_MA-UNK-UNK-STUNK")

## Name replacement as a dataframe part 2
new_member_type <- c("C232-S_OH-2018-CS-ST213", "C234-S_WI-2018-CS-ST213",
                     "C236-S_IN-2019-CS-ST213", "C239-S_OH-2019-CS-ST213",
                     "C241-S_OH-2019-CS-ST213", "C245-S_OH-2019-CS-ST213",
                     "C346-S_IN-2017-CS-ST213", "C347-S_MN-2018-CS-ST213",   
                     "C348-S_MN-2019-CS-ST213", "C349-S_MI-2018-CS-ST213",
                     "C350-S_MI-2019-CS-ST213", "C351-S_MI-2019-CS-ST213",
                     "C352-S_MI-2019-CS-ST213", "C353-S_MI-2019-CS-ST213",
                     "C354-S_NY-2018-CS-ST213", "C355-S_NY-2018-CS-ST213", 
                     "C356-S_NY-2018-CS-ST213", "C357-S_NY-2018-CS-ST213" ,  
                     "C358-S_NY-2018-CS-ST213", "C359-S_MN-2019-CS-ST213", 
                     "C360-S_MN-2019-CS-ST213", "C361-S_MN-2019-CS-ST213",
                     "C362-S_MN-2019-CS-ST213", "C363-S_MN-2019-CS-ST213", 
                     "C364-S_MN-2019-CS-ST213", "U1-U_MA-UNK-UNK-ST222",     
                     "U11-U_NY-Unknown-UNK-ST213", "U3-U_MA-UNK-UNK-ST213", 
                     "U4-U_MA-UNK-UNK-ST222", "U5-U_MA-UNK-UNK-ST222",     
                     "U6-U_MA-UNK-UNK-ST222")


replacement_table <- data.frame(old_member_type, new_member_type)
member_types <- allANI[,'X']
row_count <- nrow(replacement_table)

## Loop through and use the replacement table infromation to change names
for (i in 1:row_count) {
  search_keyword <- replacement_table[i,1]
  replace_keyword <- replacement_table[i,2]
  
  member_types <- sapply(member_types, function(x){
    x[x==search_keyword] <- replace_keyword
    return(x)
  })
}

## Final steps to convert for both column and row names
## to match
allANI[,'X'] <- member_types
update <- allANI$X
colnames(allANI) <- update

## Remove the extra column that gets generate 
allANI <- allANI[,-1]

## Move colum 1 name down by 1 and rename to X
allANI$X <- names(allANI)[1:ncol(allANI)] <- c("X", names(allANI)[1:ncol(allANI) - 1])

## Convert to long format, done for visual data checking
m1 <- reshape2::melt(allANI, variable.name = "Y")

## Now in fourth & fifth column strip names 
## to be ST values for visual sorting
m2 <- m1 %>%
  dplyr::mutate(colX_ST = str_extract(X, "[^-]+$")) %>%
  dplyr::mutate(colY_ST = str_extract(Y, "[^-]+$")) 

## Sort largest to smallest (descending) on ani value
## and on colX_ST and colY_ST
m3 <- m2[order(-m2$value),]

## Get the maximum ani value between
## ST213 and ST222, which is 99.8725
allANIMax <- m3 %>%
  dplyr::filter(colX_ST == "ST213", colY_ST == "ST222") %>%
  arrange(-value)

allANIMax <- max(allANIMax$value, na.rm = T)

## get the minimum ani value between ST213 and ST222
# 99.5043 (C196.S_MI.2016.CS.ST222 vs C234-S_WI-2018-CS-213)
allANIMin <- min(as.numeric(unlist(allANI)), na.rm=T) 

```

```{r, ST1 Meta, echo = FALSE, warning =  FALSE, message = FALSE}

########################
#      ST1 META        #
########################
## Read in ST1 metadata, which we use to determine case rate for comparison
isoBioFull <- read.csv(
  here::here('02_Manuscript/inputFiles', 
             'supplementalTable3MetaData-ST1.csv'),
  header = T, stringsAsFactors = F)

## Get counts parsed by years for ST1 
isoBioFullCount <- isoBioFull %>%
  dplyr::rename(Year = Year) %>%
  dplyr::group_by(Year) %>%          
  dplyr::summarize(caseCount = n())

## Total number of ST1, which we have both year 
## and USA location data (n = 220)
totST1 <- isoBioFullCount %>%
  tally(caseCount)

## Count st1 by sample set (state or cdc)
sampleSet1 <- isoBioFull %>%
  dplyr::group_by(sampleSet) %>%          
  dplyr::summarize(count = n())

```

```{r, ST1 Rate, echo = FALSE, warning =  FALSE, message = FALSE}
########################
#     ST1 RATE        #
########################
## Convert year to numeric to bind future prediction rows
isoBioFullCount$Year <- as.numeric(isoBioFullCount$Year)

## Dealing with the years with zero cases. We will combine
## years to give us rate of cases per year not counts.
## So for 1996 and 1998 with 1 and 4 cases respectively,
## the rate will be 5/3 and represented as year 1997

isoBioFullCount <- isoBioFullCount %>% # remove 1996 and 1998
  dplyr::slice(-c(5:6))

isoBioFullCount <- rbind(isoBioFullCount, c(1996, 5/3))
isoBioFullCount <- rbind(isoBioFullCount, c(1997, 5/3))
isoBioFullCount <- rbind(isoBioFullCount, c(1998, 5/3))

isoBioFullCount <- isoBioFullCount[order(isoBioFullCount$Year),]

## Take the log of casecount column
isoBioFullCount$caseCount <- log(isoBioFullCount$caseCount)

lModel <- lm(caseCount ~ Year, data = isoBioFullCount[1:29,])

## Store info from summary
st1Mod <- summary(lModel)

```

```{r, ST222vs1 Rate, echo = FALSE, warning =  FALSE, message = FALSE}

########################
#     ST222 VS ST1     #
########################
## Compare regression coefficients across two groups (ST222/213 and ST1s)
## For st222/213
st222 <- isoCount[1:29,]

st222Com <- st222 %>%
  dplyr::mutate("ST" = "ST222")

colnames(st222Com)[1] <- "Year"

## For st1
st1 <- isoBioFullCount[1:29,]
st1 <- st1 %>%
  dplyr::mutate("ST" = "ST1")

st222_1 <- rbind(st1, st222Com)

model <- lm(caseCount ~ Year*ST, st222_1)

## Run anova and store output to reference in text
st222_1 <-anova(model)

```

```{r, st222_213_Fisher, echo = FALSE, warning=FALSE}

## Get counts of sporadics for ST222 and ST213
isFT <- isoLoc %>%
  dplyr::filter(Year != 'Unknown' & Source != 'Environmental' ) %>%
  dplyr::filter(elGatoSTCalls == "213" | elGatoSTCalls == "222") %>%
  dplyr::distinct(Year, State, elGatoSTCalls, Type, isolateAccession) 

isFTCount <- isFT %>%
  dplyr::count(elGatoSTCalls, Type)

## Five ST222 counts, we have data for four. The only one missing is from Oregon
dat <- data.frame(
  "Outbreak" = c((isFTCount[3,3]+1), 0),
  "Sporadic" = c(isFTCount[4,3], isFTCount[1,3]),
  row.names = c("ST222", "ST213"),
  stringsAsFactors = FALSE
)

ftTest <- fisher.test(dat)

```

```{r, st222PlasmidCas, echo = FALSE, warning = FALSE, message = FALSE}

## For internal checking 
#isoTot <- isoLoc %>% dplyr::group_by(ST, Legionella.pneumophila.str..Lens.plasmid.pLPL, Legionella.pneumophila.C9_S.plasmid.unamed2,Legionella.pneumophila.FFI102, Legionella.pneumophila.plasmid.pLELO, Legionella.sainthelensi.LA01.117.plasmid.pLA01.117_150k) %>% filter(ST == 213) %>%dplyr::summarise(count = n())

## Function to get the total isolates parsed by sequence type
## and the count of isolates which do not have a plasmid

plasSum <- function(df, st) {
  
  ## don't print dplyr summarise info
  options(dplyr.summarise.inform = FALSE)
  
  ## Internal testing
  testdf <- df %>% 
    dplyr::select(grep('plasmid', names(df)), grep('FFI102', names(df)))
  
  if(ncol(testdf) == 5) {
    
    #print('The number columns matches the expected number of columns (n = 5)')
    
    isoTot <- df %>%
      dplyr::group_by(elGatoSTCalls) %>%
      filter(elGatoSTCalls == st) %>%
      summarise(totalIoslate = n())
    
    ## Improved but could be better
    plasCount <- df %>% 
      dplyr::group_by(pick(
        Legionella.pneumophila.str..Lens.plasmid.pLPL:Legionella.sainthelensi.LA01.117.plasmid.pLA01.117_150k)) %>%
      filter(elGatoSTCalls == st)%>%
      dplyr::summarise(noPlasCount = n()) %>%
      filter(Legionella.pneumophila.str..Lens.plasmid.pLPL == 0 &
               Legionella.pneumophila.C9_S.plasmid.unamed2 == 0 &
               Legionella.pneumophila.FFI102 == 0 &
               Legionella.pneumophila.plasmid.pLELO == 0 &
               Legionella.sainthelensi.LA01.117.plasmid.pLA01.117_150k == 0)
    
    ## get total of isolates which had plasmids
    data.frame(isoTot[1,2], plasCount[1,6])
    
  } else {
    print('Not what is expected, check the number of plasmid columns')
  }
}

## Output from plasSum function for each sequence type
plas213 <- plasSum(isoLoc, 213)
plas222 <- plasSum(isoLoc, 222)
plas289 <- plasSum(isoLoc, 289)

## Count number of pLP Lens plasmid parsed by ST
plpCount <- function(df, st){
  myCount <- df %>%
  dplyr::filter(elGatoSTCalls == st)
  
  myCount$Legionella.pneumophila.str..Lens.plasmid.pLPL <- as.numeric(myCount$Legionella.pneumophila.str..Lens.plasmid.pLPL)
  pLensCount <- sum(
    myCount$Legionella.pneumophila.str..Lens.plasmid.pLPL)
  pLensCount
}

pLensTotal213 <- plpCount(isoLoc, 213)
pLensTotal222 <- plpCount(isoLoc, 222)
pLensTotal289 <- plpCount(isoLoc, 289)

## Count the number of LS plasmids parsed by ST
countLS <- isoLoc %>% 
  dplyr::group_by(elGatoSTCalls, Legionella.sainthelensi.LA01.117.plasmid.pLA01.117_150k) %>%
  dplyr::summarise(countLS = n())

```

```{r st222Cas, echo = FALSE, warning = FALSE, message = FALSE}

## Determine counts on various crispr systems
cCount <- function(df, st){
  df %>%
    dplyr::group_by(elGatoSTCalls, CAS.TypeIA, CAS.TypeIC,
                    CAS.TypeIF, CAS.TypeIIB) %>%
    filter(elGatoSTCalls == st) %>%
    dplyr::summarise(casCount = n())
}

## Must subtract the first value in the row, 
## because those are isolates, which do not have
## any crispr systems found for ST222, but this
## is not the case for ST213
cas222Max <- sum(cCount(isoLoc, 222)$casCount) - cCount(isoLoc,222)$casCount[[1]]
cas213Max <- sum(cCount(isoLoc, 213)$casCount) 

## Get total number of isolates parsed by ST that do
## not have a cas system
casSum <- function(df, st) {
  testdf <- df %>% dplyr::select(grep('CAS', names(df)))
  
  if(ncol(testdf) == 4) {
    
    #print('Good, the number columns matches the expected number of columns (n = 4)')
    isoTot <- df %>%
      dplyr::group_by(elGatoSTCalls) %>%
      filter(elGatoSTCalls == st) %>%
      summarise(totalIoslate = n())
    
    casCount <- cCount(isoLoc, st) %>%
      filter(CAS.TypeIA == 0 & CAS.TypeIC == 0 &
               CAS.TypeIF == 0 & CAS.TypeIIB == 0)
    
    data.frame(isoTot[1,2], casCount[1,6])
    
  } else { 
    print('Not what is expected, check the number of plasmid columns')
  }
}

cas222Zero <- casSum(isoLoc, 222)
cas213Zero <- casSum(isoLoc, 213)

## Get number of isolates which have a TYPE I-C cas system.
## Only st222 isolates do not have a cas system (n = 3)
typeIC222 <- isoLoc %>%
  dplyr::filter(elGatoSTCalls == 222) %>%
  dplyr::filter(CAS.TypeIC == 1 | CAS.TypeIC == 2) %>%
  dplyr::summarise(type1c = n())

## Isolates with greater than one CRISPR-Cas type 
moreThan <- isoLoc %>% 
  dplyr::select(
    elGatoSTCalls, CAS.TypeIA, CAS.TypeIC, 
    CAS.TypeIF, CAS.TypeIIB) %>% 
  dplyr::filter(elGatoSTCalls != 1742 & elGatoSTCalls != 227 & 
                  elGatoSTCalls != 276 & elGatoSTCalls != 289 & 
                  elGatoSTCalls != 'NF') %>%
  dplyr::filter(CAS.TypeIC != 2) %>%
  dplyr::mutate_all( function(x) as.numeric(as.character(x))) %>%
  dplyr::mutate(as.character(elGatoSTCalls))%>%
  dplyr::mutate(Total = 
                  select(., CAS.TypeIA:CAS.TypeIIB)
                %>% rowSums(na.rm = TRUE)) %>%
  
  dplyr::group_by(elGatoSTCalls) %>%
  dplyr::summarise(counts = sum(Total > 1, na.rm = T))

## Isolates with more than one unique cas system are 
## type IC and IIB, get the count 
mostTwo <- isoLoc %>% 
  dplyr::select(
    elGatoSTCalls, CAS.TypeIA, CAS.TypeIC,
    CAS.TypeIF, CAS.TypeIIB) %>% 
  dplyr::filter(elGatoSTCalls != 1742 & elGatoSTCalls != 227 & 
                  elGatoSTCalls != 276 & elGatoSTCalls != 289) %>%
  dplyr::mutate_all( function(x) as.numeric(as.character(x))) %>%
  dplyr::filter(CAS.TypeIC != 2) %>%
  dplyr::mutate(Total = 
                  select(., CAS.TypeIC,CAS.TypeIA,CAS.TypeIIB)
                %>% rowSums(na.rm = TRUE)) %>%
  dplyr::group_by(elGatoSTCalls) %>%
  dplyr::summarise(counts = sum(Total > 1, na.rm = T))

## Get mode and max/min for spacers, 
## must data wrangling because of file format
spacerCount <- stringr::str_split_fixed(isoLoc$numOfSpacers.IA.IC.IF.IIB., "-", 3)
spacerCount <- as.data.frame(spacerCount) %>%
  mutate_all( function(x) as.numeric(as.character(x)))

## Visually identified max and min in column 2
minSpace <- min(spacerCount$V2, na.rm = T)
maxSpace <- max(spacerCount$V2, na.rm = T)

## get the mode for cas systems
mode<-function(x){which.max(tabulate(x))}
concatSapcer <- cbind(spacerCount$V1, spacerCount$V2, spacerCount$V3)
spacerMode <- mode(concatSapcer)

## Count st213 with typeIF systems
typeIF213 <- isoLoc %>% 
  dplyr::filter(CAS.TypeIF == 1) %>%
  dplyr::filter(elGatoSTCalls == 213) %>%
  dplyr::summarise(count = n()) 

## Count st213 with type IF, from MN and 2019
typeIF213MN <- isoLoc %>% 
  dplyr::filter(CAS.TypeIF == 1) %>%
  dplyr::filter(elGatoSTCalls == 213) %>%
  dplyr::filter(State == 'MN') %>%
  dplyr::filter(Year == 2019) %>%
  dplyr::summarise(count = n())

## Get count of type IA parsed by ST
typeIA <- isoLoc %>% 
  dplyr::filter(CAS.TypeIA == 1) %>%
  dplyr::group_by(elGatoSTCalls) %>%
  dplyr::summarise(count = n())

## Get total crispr systems parsed by all sts
totCC <- isoLoc %>%
  dplyr::select(elGatoSTCalls, CAS.TypeIA,
                CAS.TypeIC, CAS.TypeIF, CAS.TypeIIB) %>%
  dplyr::group_by(elGatoSTCalls) %>%
  dplyr::filter(CAS.TypeIA >= 1 | 
                  CAS.TypeIC >= 1 |
                  CAS.TypeIF >= 1 | 
                  CAS.TypeIIB >= 1) %>%
  dplyr::summarise(count = n())

## Get number of isolates with both TypeIF cas system and the pLPL plasmid
casWitPLP <- isoLoc %>%
  dplyr::filter(CAS.TypeIF == 1 & 
                  Legionella.pneumophila.str..Lens.plasmid.pLPL == 1) %>%
  dplyr::summarise(n = n())


```

\section{SUPPLEMENTAL METHODS}
*DNA extraction, Illumina sequencing, and assessing the quality of data*
  
For isolates sequenced at CDC (n = `r sampleSetST[1,2]`), genomic DNA was extracted using the Epicentre Masterpure DNA and RNA Purification Kit (cat. No. MCD85201), per the manufacturer’s instructions. CDC-based Illumina library preparation and sequencing used a protocol previously described [@mercante_genomic_2018]. Libraries were constructed using the Illumina Nextera XT Library Prep Kit (cat # FC-1311-1096) and the Nextera XT Index Kit v2 Set A (cat # VC-131-2001). We performed sequencing using the MiSeq Reagent Kit v2 (500 cycles: cat # MS-102-2003) on the Illumina MiSeq. State public health partners used their routine DNA extraction and sequencing protocols to generate data subsequently shared with the CDC (n =  `r sampleSetST[2,2]`). Those states and the number of isolates include `r stateSampleSet[1,2]` (n = `r stateSampleSet[1,3]`), `r stateSampleSet[2,2]` (n = `r stateSampleSet[2,3]`), `r stateSampleSet[3,2]` (n = `r stateSampleSet[3,3]`), `r stateSampleSet[4,2]` (n = `r stateSampleSet[4,3]`), `r stateSampleSet[5,2]` (n = `r stateSampleSet[5,3]`), `r stateSampleSet[6,2]` (n = `r stateSampleSet[6,3]`), and `r stateSampleSet[7,2]` (n = `r stateSampleSet[7,3]`). We uploaded the raw Illumina data sequenced in-house or from the state partners to the NCBI Sequence Read Archive (SRA) under BioProject PRJNA861313.

FASTQC v0.11.9 [@andrews_fastqc_2010] determined the quality of the Illumina reads and summarized with MultiQC v1.9 [@ewels_multiqc_2016]. We used Trimmomatic v0.39 [@bolger_trimmomatic_2014] to (i) remove the adapter and primer sequences, (ii) trim low-quality bases (quality score < 20) from the ends of the reads, (iii) remove low-quality reads (average quality score < 20), and (iv) remove reads with length < 75bp. We used SPAdes v3.13.0 [@prjibelski_using_2020] for *de novo* genome assembly with the -careful flag and filtered assemblies to remove contigs that were < 1000bp. We assessed assembly quality using QUAST v5.0.2 [@gurevich_quast_2013] and compared the assemblies to *Legionella pneumophila* Philadelphia-1 (NZ_CP013742.1). We provide summary statistics for the reads and assemblies (Supplemental Table 2). 

*Sequence types, clonal complex analysis, and phylogenetics*
  
For a subset of isolates, ST was determined using the traditional Sanger sequence-based method following standard procedures [@gaia_sequence-based_2003]; additionally, ST was determined for all isolates bioinformatically using the whole-genome sequencing data and the el_gato program (https://github.com/appliedbinf/el_gato). Both methods rely on the ESGLI SBT database to assign isolates an allelic profile based on a panel of seven loci (*flaA*, *pilE*, *asd*, *mip*, *mompS*, *proA*, and *neuA/neuAh*) corresponding to an ST  [@gaia_sequence-based_2003; @gaia_consensus_2005; @ratzow_addition_2007; @luck_typing_2013]. While typing of most of the loci occurs using an exact matching paradigm via NCBI Blastn, *mompS* is sometimes duplicated, and el_gato specifically resolves the duplicated *mompS* locus using the target primer sequences and read orientation to differentiate between multiple copies to infer the correct locus. Additionally, *neuA/neuAh* is known to be genetically heterogeneous, and el_gato relies on multiple references (n = 4) to resolve this locus via mapping [@mentasti_extension_2014].

PHYLOViZ v2.0 [@nascimento_phyloviz_2017] created a minimum spanning tree of the eleven STs, making up the ST213/222 clonal complex and visualized in R v4.0.5 [@r_core_team_r_2021]. Our dataset lacked sequence data for five STs within the clonal complex (ST1601, ST2728, ST2497, ST2517, and ST2519). To evaluate the genetic relationship between ST213/222 and other STs, we identified the ten most prevalent STs submitted to CDC between 1992 and 2020, derived from a clinical source and for which we had generated whole-genome sequence data. Those STs were ST1, ST36, ST42, ST62, ST94, ST187, ST213, ST222, ST242, and ST731. Additionally, we included single-locus variants of ST213 (ST289, n = 2) and ST222 (ST1742, n = 1) as they are part of the ST213/222 clonal complex but were not identified as being among the top ten clinical STs. For each ST, we randomly selected three isolates from the entire CDC *Legionella* collection from 1992 – 2020 and generated a core single nucleotide polymorphism (SNP) alignment of 127,698 SNPs via SNIPPY [@seemann_snippy_2015] using the NZ_CP012019 genome (Toronto-20052, ST222) as our reference genome. We removed SNPs occurring in recombinant regions as detected by Gubbins v3.0.0 [@croucher_rapid_2015] using default settings, which reduced the number of polymorphic sites to 98,708. Using this reduced SNP alignment, we inferred a maximum likelihood phylogenetic tree using  RAxML v8.2.12 [@stamatakis_raxml_2014] with a general time reversible evolutionary model, a discrete gamma-distribution to estimate heterogeneity across sites (GTRGAMMA) and 100 bootstrap replicates. The single tree with the highest likelihood score was selected as the best tree and the phylogeny was visualized and annotated in R v4.0.5 [@r_core_team_r_2021] using the ape package v5.6.2 [@paradis_ape_2019] and ggtree v3.6.2 [@yu_ggtree_2017]. 

We compared whole-genome assemblies of isolates using all-against-all pairwise average nucleotide identity (ANI), calculated using dnadiff from MUMmer v4.0.0 [@marcais_mummer4_2018]. We converted ANI values to a distance measure (100 – ANI%; Supplemental Table 4) and used it to construct a Neighbor-Joining (NJ) phylogenetic tree [@saitou_neighbor-joining_1987] in MEGA7 [@kumar_mega7_2016]. This phylogeny, including relevant metadata, was visualized using the interactive tree of life [@letunic_interactive_2019].

*Plasmid and CRISPR-Cas system identification*
  
We identified plasmids in our data using the program PIMA (https://github.com/appliedbinf/pima). PIMA uses the database of RefSeq sequences [@oleary_reference_2016] between 1,000-500,000 bp with “plasmid” in the description. We accessed the database on October 13, 2020. From potential hits, we removed plasmids with < 75% coverage of the reference plasmid to reduce the occurrence of false positives. RNA operon screening occurred via RNAmmer [@lagesen_rnammer_2007] and NCBI blastn [@camacho_blast_2009]. If an identified plasmid contained RNA operons and was not previously associated with *Legionella*, it was considered a false positive (e.g., *Escherichia coli* plasmid pV294-a). Additionally, sequences identified as PhiX were considered false positives and removed from possible hits. CRISPR-Cas Finder v4.2.20 [@couvin_crisprcasfinder_2018] was used to identify CRISPR-Cas systems. We filtered the results to include only those identified as having the highest evidence level (level = 4), CRISPR arrays associated with *cas* genes, and within 30 kb of *cas* genes.

*Gene annotation and pan-genome analysis*
  
We performed gene annotation using Prokka v1.14.5 [@seemann_prokka_2014], specifying a *Legionella*-specific BLAST database. We performed gene clustering and pan-genome analysis using Roary v3.11.2 [@page_roary_2015], setting the\emph{-cd} parameter to 100, which requires genes to be present in 100% of the isolates to be considered core. Before pan-genome comparisons, we filtered isolates to remove clonal outbreak isolates based on an ANI score of ≥ 99.99, keeping only one isolate per outbreak (Supplemental Table 2). We compared isolates recovered from 2001 through 2020 within geographic and temporal subgroups. We only included bins with 14 or more isolates in our analysis. For example, we did not perform pan-genome analysis for Southwest regional isolates as the number of isolates within this bin is low (n = 5). We did not include a year before 2001, as sampling is also low (n = 5). Region bins with ≥ 14 isolates included Northeast (`r regionCount[3,1]`: n = `r regionCount[3,2]`; CT, MA, MD, ME, NH, NY, PA, RI, and VT), Central (`r regionCount[1,1]`: n = `r regionCount[1,2]`; IL, IN, MO, and OH), and  North Central (`r regionCount[2,1]`: n = `r regionCount[2,2]`; MI, MN, and WI) regions. Temporal comparisons included five-year bins of isolates from all areas (`r yearBin[1,1]`, n = `r yearBin[1,2]`; `r yearBin[2,1]`, n = `r yearBin[2,2]`; `r yearBin[3,1]`, n = `r yearBin[3,2]`; `r yearBin[4,1]`, n = `r yearBin[4,2]`). We excluded isolates that had an unknown collection date or state location or were not ST222 or 213 from temporal and regional pan-genome analyses.

*Obtaining completely closed L. pneumophila genomes using Pacific Biosciences technology*

We followed the single molecule real-time (SMRT) sequencing method to prepare 15 - 20 kb SMRTbell template libraries with the Blue Pippin size selection system (Sage Science, Beverly, MA). The final size of the insert libraries was 20 kb for C175, 18.2 kb for C177, and 15 kb for C217. We used the Covaris g-TUBE (Woburn, MA, USA) and the SMRTbell Template Prep Kit 1.0 for shearing genomic DNA and ligating hairpin adapters onto DNA templates, respectively. We performed annealing and binding using the DNA/Polymerase Binding Kit P6 v2 via the P6C4 chemistry on the PacBio RSII sequencing instrument with a single SMRT Cell v3 over a 240-minute movie period.

We sequenced three isolates via Pacific Biosciences (Menlo Park, CA, USA): C175 (ST222), C177 (ST213), and C217 (ST213). We performed library construction, sequencing, and assembly as previously described [@mercante_genomic_2016; @kozak-muiznieks_comparative_2018]. We performed sequencing analysis using the hierarchical genome-assembly process (HGAP) through SMRT Analysis version 2.3.0. To construct a completely closed *L. pneumophila* genome, we used the Pacific Biosciences HGAP3 assembler [@chin_nonhybrid_2013]. Parameters for the HGAP3 assembler included an expected genome size of 3.4 mb and 15x target genome coverage. We used a previously described approach to reduce the genome depth of coverage and identify nucleotide discrepancies between PacBio and Illumina sequencing data [@kozak-muiznieks_comparative_2018]. NCBI BioProject PRJNA931318 contains the complete, error-corrected genomes sequenced in this study.

To generate a comparative genomic map, CGView was used to compare the PacBio completed whole-genome assemblies [@stothard_circular_2005], which operates BLAST version 1.1.0 for the comparisons. Percent identity is calculated for the three isolates, with 100, 90, or 70% matching identity bins, and based on the Toronto-20052 genome assembly (NZ_CP012019, ST222). To evaluate genomic synteny, we ran progressiveMauve [@darling_progressivemauve_2010] for the three PacBio isolates, and the same reference sequence used in the CGView analysis (NCBI Reference Sequence: NZ_CP012019, ST222).

\section{SUPPLEMENTAL RESULTS}

*Pan-genome analysis for five-year bins*

Isolates collected in `r yearBin[1,1]` (n = `r yearBin[1,2]`) had 2,914 core genes with 794 accessory genes, isolates from `r yearBin[2,1]` (n = `r yearBin[2,2]`) had 2,888 core genes with 984 accessory genes, isolates from `r yearBin[3,1]` (n = `r yearBin[3,2]`) had 2,860 core genes with 1,677 accessory genes, and isolates collected in `r yearBin[4,1]` (n = `r yearBin[4,2]`) had 2,569 core genes with 2,754 accessory genes (Supplemental Figure 4a). The percent of core genes ranges from 48 – 79% (2001-2005: Core = 79%, 2006-2010: Core = 75%, 2011 – 2015: Core = 63%, and 2016 – 2020: Core = 48%) while the percent of singleton genes ranges from 8 – 20% (2001-2005: Singleton = 8%, 2006-2010: Singleton = 12%, 2011-2015: Singleton = 15%, and 2016-2020: Singleton = 20%). When the rarefaction analysis was conducted on isolates parsed by year in five-year bins, the only bins with a large sampling set were `r yearBin[3,1]` (n = `r yearBin[3,2]`) and `r yearBin[4,1]` (n = `r yearBin[4,2]`) as indicated with a plateau for each year-bin (Supplemental Figure 4b). While the bins with the fewest isolates (`r yearBin[1,1]`, n = `r yearBin[1,2]` and `r yearBin[2,1]`, n = `r yearBin[2,2]`) had the steepest slope, indicating that if we increased the number of isolates for those year bins, then we could identify additional core and accessory genes (Supplemental Figure 4b). Even so, with these year bins with few isolates, one could still evaluate core and accessory gene gain or loss for these year bins to understand how these ST213/222 isolates change over time. 

\newpage 
\section{SUPPLEMENTAL FIGURE LEGENDS}

**Supplemental Figure 1:** We generated this plot via the\emph{checkresiduals()} function in R from the forecast package v8.17.0 (23), where we confirm that the residual errors are white noise for estimating the rate of LD per year with forecasting for ST213/222. When residual errors are considered white noise, there is no additional information to extract from the data. A) The time plot of the residuals from the model shows that the variation is essentially the same. The only exception is for the year 2020. Additionally, there is no trend, seasonality, or cyclical behavior. Therefore, we treat the residual variance as constant. B) Autocorrelation Function (ACF) Plot: No peaks beyond the 95% limits defined by the dashed blue line as expected for a white noise series that shows no autocorrelation, an assumption in time series data analysis. C) Residual histograms: The model’s residuals follow a normal distribution, in which the histogram is centered on zero, although it is slightly left skewed. 

**Supplemental Figure 2:** We generated this plot via the\emph{checkresiduals()} function in R from the forecast package v8.17.0 (23), where we confirm that the residual errors are white noise for estimating the rate of LD per year with forecasting for ST1. When residual errors are considered white noise, there is no additional information to extract from the data. Thus, the remaining information is noise. A) As seen in the time plot of the residuals, there is fluctuation in cases resulting from ST1. For example, there was a decrease in cases during 2006, followed by an uptick. Additionally, there is no trend, seasonality, or cyclical behavior. Therefore, we treat the residual variance as constant. B) Autocorrelation Function (ACF) Plot: No peaks beyond the 95% limits defined by the dashed blue line as expected for a white noise series that shows no autocorrelation, an assumption in time series data analysis. C) Residual histograms: The model’s residuals follow a normal distribution, in which the histogram is centered on zero, although it is slightly left skewed.  

**Supplemental Figure 3:** Plots of pan-genome analyses for regional bins of isolates found in the Northeast, Central, and North Central regions only include ST213 and ST222 isolates. a) The percentage of genes parsed by region identified for each pan-genome category. Core genes are the highest in the regional bins compared to the other gene categories. The x-axis also includes the number of isolates for each regional bin. b) Plot of genes that are either present in all isolates (dark blue) or absent in all isolates (gray) parsed by each regional bin. The rows are Northeast, North Central, and Central regions and include the number of isolates used to generate the plot. There is overlap between the three regional bins for many genes, while some genes are absent in one or two regional bins. c) Rarefaction curve generated for the three regional bins. The x-axis is the number of genomes, the y-axis is the number of genes, the dashed lines represent the total genes, and the solid line represents the total number of core genes for each bin.  

**Supplemental Figure 4:** Plots of pan-genome analyses for year bins based on five-year bins. Those bins are 2001-2005, 2006-2010, 2011-2015, and 2016-2020 and only include ST213 and ST222 isolates. a) The percentage of genes parsed by year identified for each pan-genome category. Core genes are the highest in the year bins compared to the other gene categories. The x-axis also includes the number of isolates for each year bin. b) Rarefaction curve generated for the five-year bins. The x-axis is the number of genomes, the y-axis is the number of genes, the dashed lines represent the total genes, and the solid line represents the total number of core genes for each bin.

\newpage
\section{SUPPLEMENTAL TABLE HEADERS}

**Supplemental Table 1:** Predictive effect of non-synonymous changes in the *neuA* gene for ST213 and ST222. Using snap2 [@hecht_better_2015], we determine the impact of non-synonymous changes from ST213 to ST222 or vice versa. The variant column is listed as amino acid found in isolate 1, position, amino acid found in isolate 2, and the identity of isolate 1 and 2 is based on the comparison column. The score column can range from -100 (strong neutral effect) to 100 (strong predictive effect). The expected accuracy column ranges from 0 – 100% for their mutation score and functional outcome predictions.

**Supplemental Table 2:** All metadata for ST213/222 clonal complex isolates analyzed in this manuscript. Column header definitions: isolateAccession – the accession number used to discuss isolates within this manuscript, includedInAnalysiForMS – include/exclude designation as two isolates (C180 and U10) are uploaded to the Bioproject associated with this manuscripts data, elGatoSTCalls – ST identified via el_gato,  cdcID – identifier within CDC database, sampleSet – whether the isolate was sequenced internally at CDC or at State Public Health Laboratories, Year – when the isolate was collected, Region – our assignment to the four different regions except for one isolate from Canada that was not included in any of the analyses (C180), State – represents states within the USA except for one isolate from Canada that was not included in any of the analyses (C180), SangerSequenceSBT – Isolates which have ST confirmed via Sanger sequencing (Y) or isolates which did not have ST confirmed by Sanger sequencing (N), Source – assignment based on the source of the collection (Clinical, Environmental, or Unknown), Type – assignment based on the occurrence type (Sporadic, Outbreak, Outbreak Environmental, or Unknown) PanGenomeRegion – if an isolate was part of the pangenome regional analysis, whyExcludeRegion – why an isolate was excluded from pangenome regional analysis, panGenomeYear – if an isolate was part of the pangenome year analysis and its associated year bin, whyExcludeYear – why an isolate was excluded from pangenome year analysis, NCBI_BioProject – NCBI Bioproject designation for each isolate, NCBI_SRR – NCBI SRR identifier for each isolate, dataUseConfirmed – confirmation from State Public Health Laboratories that data could be uploaded to NCBI, spadesAssemblyLength – Length of assembly after using Spades, spadesN50 – N50 value for each isolate based on spades assemblies, spadesNumberofContigs>1kb – number of contigs in the spades assembly output greater than 1 kb, preQC-AvgReadLength – average read length before running quality control steps based on read 1 for each isolate determined by QUAST, preQC-NumberOfReads – number of reads before running quality control steps based on read 1 for each isolate determined by QUAST, preQC-Coverage – estimated coverage before running quality control steps based on read 1 for each isolate determined by QUAST, preQC-OverallSequenceQuality – binary value of good or bad before running quality control steps based on read 1 for each isolate determined by QUAST, postQC-AvgReadLength – average read length after running quality control steps based on read 1 for each isolate determined by QUAST, post QC-NumberOfReads – number of reads after running quality control steps based on read 1 for each isolate determined by QUAST, postQC-Coverage – estimated coverage after running quality control steps based on read 1 for each isolate determined by QUAST, postQC-OverallSequenceQuality – binary value of good or bad after running quality control steps based on read 1 for each isolate determined by QUAST, numOfSpacers (number of spacers) - if an isolate had greater than one CRISPR-Cas system, then the number of spacers for each system are separated by a dash (e.g., 45-25), which follows the order of Type I-A, Type I-C, Type I-F, Type II-B. CAS-TypeIA – Absence or presence of CAS-Type I-A in each isolate, CAS-TypeIC - Absence or presence of CAS-Type I-C in each isolate, CAS-TypeIF - Absence or presence of CAS-Type I-F in each isolate, CAS-TypeIIB - Absence or presence of CAS-Type II-b in each isolate, *L. pneumophila* str. Lens plasmid pLPL - Absence or presence of this plasmid in each isolate, *L. pneumophila* C9_S plasmid unamed2 - Absence or presence of this plasmid in each isolate, *L. pneumophila* FFI102 - Absence or presence of this plasmid in each isolate, *L. pneumophila* plasmid pLELO - Absence or presence of this plasmid in each isolate, *Legionella sainthelensi* LA01-117 plasmid pLA01-117_150k - Absence or presence of this plasmid in each isolate. Lastly two isolates were excluded from all analyses that are in this table: C180 and U10. C180 is excluded because its collection location is Canada and U10 was excluded as it is not an officially accepted sequence type in the ESGLI ST database for the ST213/222 clonal complex.

**Supplemental Table 3:** Metadata for ST1 isolates used for estimating the rate of cases associated with this ST. Column header definitions: Year - when the isolate was collected, Sample - Unique identifier, Source – Source of each specimen CS: clinical specimen, OC: outbreak clinical, State – represents states within the USA, and sampleSet – whether the isolate was sequenced internally at CDC or State Public Health Laboratories.  

**Supplemental Table 4:** Average nucleotide identity (ANI) values for all pairwise comparisons of ST213 and ST222.

**Supplemental Table 5:** Genes present only in the C217 (ST213) PacBio genome compared with the three other PacBio genomes using the Toronto-20052 genome (NZ_CP012019, ST222) as a reference on which the start and stop are based. Note that this list excludes all possible genes missing in ST213 compared to ST222 and only contains those genes in this isolate for the region located at 188 kb. Column headers: onlyInC217 – Presence in C217 compared to NZ_CP012019 genome (ST222), start..stop - positional coordinates for each gene based on the NZ_CP012019 genome (ST222), productFromProkka – protein-coding gene annotations from Prokka, productFromNZ_CP012019 – concordant protein-coding gene product from the NZ_CP012019 genome, proteinID – corresponding NCBI protein ID, aminoAcidSequence – matching amino acid sequence from Prokka annotations and NCBI annotations.  

**Supplemental Table 6:** Genes absent in C217 (ST213) PacBio genomes compared with ST222 PacBio genome using the Toronto-20052 genome (NZ_CP012019, ST222) as a reference. The start and stop are based on the NZ_CP012019 genome (ST222). Note that this list excludes all possible genes missing in ST213 compared to ST222 and only contains those not found in the missing segments at ~90 kb and ~950 kb for ST213 (C217). Column headers: missingInST213 – absence in C177 and C217 genomes compared to NZ_CP012019 genome (ST222), start..stop - positional coordinates for each gene based on the NZ_CP012019 genome (ST222), productFromProkka – protein-coding gene annotations from Prokka, productFromNZ_CP012019 – concordant protein-coding gene product from the NZ_CP012019 genome (ST222), proteinID – corresponding NCBI protein ID, aminoAcidSequence – matching amino acid sequence from Prokka annotations and NCBI annotations.

**Supplemental Table 7:** This table lists the metadata for the clinical isolates selected at random to generate the SNP phylogeny of sequence types. Metadata includes an alternative identifier (sampleID), sequence type (ST), location for collection of isolates (State), and date of collection (Year). 

\newpage